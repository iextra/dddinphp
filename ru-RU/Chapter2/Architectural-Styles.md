# 2. Архитектурные стили
Чтобы иметь возможность создавать сложные приложения, одним из ключевых требований является наличие 
архитектурного проекта, соответствующего потребностям приложения. Одним из преимуществ доменно-ориентированного 
проектирования является то, что оно не привязано к какому-либо конкретному стилю архитектуры. 
Вместо этого мы свободны выбирать архитектуру, которая лучше всего соответствует потребностям каждого 
ограниченного контекста внутри основного домена, который предлагает разнообразный набор архитектурных решений 
для каждой конкретной проблемы домена.

Например, система обработки заказов может использовать источник событий для отслеживания всех различных операций 
с заказами; Каталог продуктов может использовать CQRS для предоставления сведений о продукте различным клиентам; 
а система управления контентом может использовать простую шестиугольную архитектуру для предоставления таких требований,
как блоги, статические страницы и т. д.

В этой главе представлено введение во все соответствующие архитектурные стили в мире PHP, прослеживающие эволюцию 
от традиционного PHP-кода «старой школы» к более сложной архитектуре. Обратите внимание: хотя существует множество 
других существующих архитектурных стилей, таких как Data Fabric или SOA, мы считаем их слишком сложными 
для представления с точки зрения PHP.

## 2.1 Старые добрые времена
До выпуска PHP 5 язык не поддерживал объектно-ориентированную парадигму. В то время обычным способом написания 
приложений было использование процедур и глобального состояния. Такие концепции, как разделение ответственности, 
MVC и тому подобное, были чужды сообществу PHP. В приведенном ниже примере показано приложение, 
написанное традиционным способом, где приложения состоят из множества фронт-контроллеров, смешанных с HTML-кодом. 
За это время код уровней инфраструктуры, представления, пользовательского интерфейса и предметной области перепутался:

```php
<?php
include __DIR__ . '/bootstrap.php';

$db = new PDO('mysql:host=localhost;dbname=my_database', 'a_username', '4_p4ssw0\ rd', [
    PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES utf8mb4',
]);

$errormsg = null;

if (isset($_POST['submit'] && isValid($_POST['post'])) { 
    $post = getFrom($_POST['post']); 
    $db->beginTransaction();
    
    try {
        $stm = $db->prepare('INSERT INTO posts (title, content) VALUES (?, ?)'); 
        $stm->execute([
            $post['title'],
            $post['content']
        ]);
        $db->commit();
    } catch (Exception $e) {
        $db->rollback();
        $errormsg = 'Post could not be created! :(';
    }
}
$stm = $db->prepare('SELECT id, title, content FROM posts'); 
$posts = $stm->fetchAll(PDO::FETCH_ASSOC);
?>
<html>
    <head></head>
    <body>
        <?php if (null !== $errormsg): ?>
            <div class="alert error"><?php echo $errormsg; ?></div>
        <?php else: ?>
            <div class="alert success">Bravo! Post was created successfully!</div> 
        <?php endif; ?>
        
        <table>
            <thead><tr><th>ID</th><th>TITLE</th><th>ACTIONS</th></tr></thead> 
            <tbody>
                <?php foreach ($posts as $post): ?>
                    <tr>
                        <td><?php echo $post['ID']; ?></td> 
                        <td><?php echo $post['TITLE']; ?></td> 
                        <td><?php editPostUrl($post['ID']); ?></td>
                    </tr>
                <?php endforeach; ?> 
            </tbody>
        </table>
    </body>
</html>

```

Этот стиль кодирования часто Большой Ком Грязи (Big Ball of Mud), о котором мы упоминали в первой главе. Однако улучшение, 
замеченное в этом стиле, заключалось в инкапсуляции верхнего и нижнего колонтитула веб-страницу в отдельных файлах,
которые были включены в файлы верхнего и нижнего колонтитула. 
Это позволило избежать дублирования и способствовало повторному использованию.

```php
<?php
include __DIR__ . '/bootstrap.php';

$db = new PDO('mysql:host=localhost;dbname=my_database', 'a_username', '4_p4ssw0\ rd', [
    PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES utf8mb4',
]);

$errormsg = null;

if (isset($_POST['submit'] && isValid($_POST['post'])) { 
    $post = getFrom($_POST['post']); 
    $db->beginTransaction();
    
    try {
        $stm = $db->prepare('INSERT INTO posts (title, content) VALUES (?, ?)'); 
        $stm->execute([
            $post['title'],
            $post['content']
        ]);
        $db->commit();
    } catch (Exception $e) {
        $db->rollback();
        $errormsg = 'Post could not be created! :(';
    }
}
$stm = $db->prepare('SELECT id, title, content FROM posts'); 
$posts = $stm->fetchAll(PDO::FETCH_ASSOC);
?>
<?php include __DIR__ . '/header.php'; ?>

<?php if (null !== $errormsg): ?>
    <div class="alert error"><?php echo $errormsg; ?></div>
<?php else: ?>
    <div class="alert success">Bravo! Post was created successfully!</div> 
<?php endif; ?>

<table>
    <thead><tr><th>ID</th><th>TITLE</th><th>ACTIONS</th></tr></thead> 
    <tbody>
        <?php foreach ($posts as $post): ?>
            <tr>
                <td><?php echo $post['ID']; ?></td> 
                <td><?php echo $post['TITLE']; ?></td> 
                <td><?php editPostUrl($post['ID']); ?></td>
            </tr>
        <?php endforeach; ?> 
    </tbody>
</table>

<?php include __DIR__ . '/footer.php'; ?>
```

В настоящее время, хотя это крайне не рекомендуется, все еще существуют приложения, использующие этот 
процедурный способ кодирования. Основным недостатком этого стиля архитектуры является отсутствие реального 
разделения задач — затраты на обслуживание и развитие разрабатываемого таким образом приложения резко возрастают 
по сравнению с другими известными и проверенными архитектурами.

## 2.2 Многоуровневая архитектура
С точки зрения удобства сопровождения кода и повторного использования лучший способ сделать этот код немного 
проще в обслуживании — это разделить концепции — создать уровни для каждой отдельной задачи. 
В нашем предыдущем примере легко сформировать несколько разных уровней: один для инкапсуляции доступа к данным 
и манипулирования ими, другой для решения проблем инфраструктуры и последний для инкапсуляции оркестрации 
двух предыдущих. Важным правилом многоуровневой архитектуры является то, что каждый уровень должен быть тесно связан 
со слоями, находящимися под ним, как показано на следующем рисунке:

![Многоуровневая архитектура](https://github.com/iextra/dddinphp/blob/main/ru-RU/img/image-0001.jpeg)

Чего на самом деле добивается многоуровневая архитектура, так это разделения различных компонентов приложения. 
Например, в рамках предыдущего примера представление сообщения в блоге должно быть полностью независимым 
от сообщения в блоге как концептуальной сущности. Вместо этого сообщение в блоге как концептуальная сущность 
может быть связано с одним или несколькими представлениями, а не быть тесно связанным с конкретным представлением. 
Это обычно называется разделением интересов.

Другая архитектурная парадигма и шаблон, преследующие ту же цель, — это шаблон Модель-Представление-Контроллер. 
Первоначально он задумывался и широко использовался для создания настольных приложений с графическим интерфейсом, 
а теперь в основном используется в веб-приложениях благодаря популярным веб-фреймворкам,
таким как Symfony, Zend Framework и CodeIgniter.

## 2.2.1 Модель-Представление-Контроллер
Модель-Представление-Контроллер — это архитектурный шаблон и парадигма, которая делит приложение на три основных слоя, описанных ниже.

• Модель: фиксирует и централизует все поведение модели домена. Этот уровень управляет всеми
данными, логикой и бизнес-правилами независимо от представления данных. Было сказано, что уровень **модели является сердцем и душой каждого приложения MVC**.
• Контроллер: организует взаимодействия между другими уровнями, запускает действия в модели для обновления ее состояния и обновляет представления, связанные с моделью.
Кроме того, контроллер также может отправлять сообщения в уровень представления для изменения
определенного представления модели.
• Представление: это уровень, основная цель которого — раскрыть различные представления уровня модели и предоставить способ запуска изменений состояния модели.

![MVC шаблон](https://github.com/iextra/dddinphp/blob/main/ru-RU/img/image-0002.png)

## 2.2.2 Пример многоуровневой архитектуры

### 2.2.2.1 Модель
Следуя предыдущему примеру, мы упомянули, что различные проблемы должны быть разделены. Чтобы сделать это, все слои должны быть идентифицированы в нашем исходном запутанном коде. В ходе этого процесса нам нужно
уделять особое внимание коду, соответствующему слою Модели, который будет бьющимся сердцем
приложения:

```php
<?php

class Post
{
    private $title;
    private $content;

    public static function writeNewFrom($title, $content)
    {
        return new static($title, $content);
    }

    private function __construct($title, $content)
    {
        $this->setTitle($title);
        $this->setContent($content);
    }

    private function setTitle($title)
    {
        if (empty($title)) {
            throw new RuntimeException('Title cannot be empty');
        }

        $this->title = $title;
    }

    private function setContent($content)
    {
        if (empty($content)) {
            throw new RuntimeException('Content cannot be empty');
        }

        $this->content = $content;
    }
}

class PostRepository
{
    private $db;

    public function __construct()
    {
        $this->db = new PDO(
            'mysql:host=localhost;dbname=my_database',
            'a_username',
            '4_p4ssw0rd',
            [
                PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES utf8mb4',
            ]
        );
    }

    public function add(Post $post)
    {
        $this->db->beginTransaction();

        try {
            $stm = $this->db->prepare(
                'INSERT INTO posts (title, content) VALUES (?, ?)'
            );
        
            $stm->execute([
                $post->title(),
                $post->content(),
            ]);

            $this->db->commit();
        } catch (Exception $e) {
            $this->db->rollback();
            throw new UnableToCreatePostException($e);
        }
    }
}
```

Слой Модели теперь определяется классом Post и классом PostRepository. Класс Post представляет запись в блоге, а класс PostRepository представляет всю коллекцию доступных записей в блоге. Кроме того, внутри Модели требуется ещё один слой - слой, который координирует и оркестрирует поведение Доменной Модели. Встречайте, это Прикладной слой (Application Layer).

```php
class PostService
{
    public function createPost($title, $content)
    {
        $post = Post::writeNewFrom($title, $content);

        (new PostRepository())->add($post);

        return $post;
    }
}
```

PostService известен как Прикладной Сервис (Application Service), и его задача - координировать и организовывать поведение домена. Другими словами, прикладные сервисы - это те, которые заставляют вещи происходить, и они являются прямыми клиентами доменной модели. Никакой другой тип объекта не должен иметь возможность напрямую взаимодействовать с внутренними слоями слоя модели.

### 2.2.2.2 Представление

Представление - это слой, который может как получать, так и отправлять сообщения из слоя Модели и/или слоя Контроллера. Его основная цель - представлять Модель пользователю на уровне пользовательского интерфейса, а также обновлять представление в пользовательском интерфейсе каждый раз, когда Модель обновляется. В общем, слой Представления получает объект - часто объект переноса данных (DTO) вместо экземпляров слоя Модели - собирая все необходимую информацию для успешного представления. Для PHP существует несколько шаблонных движков, которые могут значительно помочь в отделении представления Модели от самой Модели и от Контроллера. Самый популярный из них называется Twig. Давайте посмотрим, как будет выглядеть слой Представления с использованием Twig.

````
DTO вместо экземпляров модели?
Это старый и актуальный вопрос. Зачем создавать DTO вместо передачи экземпляра Модели слою Представления? Основная причина и короткий ответ - это, опять же, разделение обязанностей. Позволение Представлению проверять и использовать экземпляр Модели приводит к тесной связи между слоем Представления и слоем Модели. Фактически, изменение в слое Модели потенциально может нарушить все представления, которые используют измененные экземпляры Модели.
````

```twig
{% extends "base.html.twig" %}

{% block content %}
{% if errormsg is defined %}
<div class="alert error">{{ errormsg }} </div>
{% else %}
<div class="alert success">Bravo! Post was created successfully!</div>
{% endif %}
<table>
    <thead><tr><th>ID</th><th>TITLE</th><th>ACTIONS</th></tr></thead>
    <tbody>
    {% for post in posts %}
    <tr>
        <td>{{ post.id }}</td>
        <td>{{ post.title }}</td>
        <td><a href="{{ editPostUrl(post.id) }}">Edit Post</a></td>
    </tr>
    {% endfor %}
    </tbody>
</table>
{% endblock %}
```
Чаще всего, когда модель вызывает изменение состояния, она также уведомляет связанные представления, чтобы пользовательский интерфейс мог обновиться. В типичном веб-сценарии синхронизация между моделью и её представлениями может быть немного сложной из-за клиент-серверной природы. В таких условиях обычно требуются взаимодействия, определённые на JavaScript, для поддержания этой синхронизации. По этой причине в последние годы широкую популярность приобрели JavaScript-фреймворки MVC

### 2.2.2.3 Контроллер
Контроллер отвечает за организацию и координацию работы Представления (View) и Модели (Model). Он принимает сообщения от слоя Представления и запускает поведение Модели для выполнения требуемого действия. Кроме того, Контроллер отправляет сообщения Представлению для отображения представлений Модели. Обе эти операции осуществляются благодаря Слою Приложения (Application Layer), который отвечает за координацию, организацию и инкапсуляцию поведения Домена (Domain).

В контексте веб-приложения на PHP Контроллер, как правило, представлен набором классов, которые, чтобы выполнять свои функции, "работают с HTTP". Иными словами, они принимают HTTP-запрос и возвращают HTTP-ответ.

```php
class PostsController
{
    public function updateAction(Request $request)
    {
        if ($request->request->has('submit')
            && Validator::validate($request->request->post)
        ) {
            $postService = new PostService();

            try {
                $postService->createPost(
                    $request->request->get('title'),
                    $request->request->get('content')
                );

                $this->addFlash(
                    'notice',
                    'Post has been created successfully!'
                );
            } catch (Exception $e) {
                $this->addFlash(
                    'error',
                    'Unable to create the post!'
                );
            }
        }

        return $this->render('posts/update-result.html.twig');
    }
}
```

## 2.3 Инверсия зависимостей: Гексагональная архитектура

Следуя основному принципу слоистой архитектуры, существует риск реализации интерфейсов домена, которые зависят от инфраструктурных аспектов в слое доменной модели. Например, если мы используем архитектуру MVC, то PostRepository из предыдущего примера должен находиться в слое доменной модели. Однако размещение инфраструктурных деталей непосредственно в центре домена нарушает принцип разделения обязанностей (Separation of Concerns).

Это может создать проблемы: становится сложно избежать нарушения основных принципов слоистой архитектуры, что, в свою очередь, приводит к созданию стиля кода, который становится трудно тестировать, если слой домена осведомлен о технических реализациях.

### 2.3.1 Принцип инверсии зависимостей (DIP)
Как мы можем это исправить? Поскольку слой Domain Model зависит от конкретных реализаций инфраструктуры, можно применить принцип инверсии зависимостей (DIP), переместив слой инфраструктуры поверх других трех слоев.

````
Принцип инверсии зависимостей
Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Роберт С. Мартин
````

Используя принцип инверсии зависимостей, архитектурная схема меняется, и слой инфраструктуры, который можно рассматривать как модуль низкого уровня, теперь зависит от UI, слоя приложения и слоя домена, которые являются модулями высокого уровня. Зависимость была инвертирована.

Но что такое шестиугольная архитектура и как она вписывается в это все? Шестиугольная архитектура (также известная как Ports and Adapters) была определена Алистером Кокберном в его книге Hexagonal Architecture и представляет приложение в виде шестиугольника, где каждая сторона представляет Порт с одним или несколькими Адаптерами. Порт — это соединитель с подключаемым адаптером, который преобразует внешний ввод в формат, понятный внутреннему приложению. С точки зрения принципа инверсии зависимостей, Порт будет модулем высокого уровня, а Адаптер — модулем низкого уровня. Более того, если приложению нужно отправить какое-то сообщение во внешнюю среду, оно также будет использовать Порт с Адаптером для отправки и преобразования сообщения в формат, понятный внешней среде.

По этой причине шестиугольная архитектура вводит концепцию симметрии в приложении, и это основная причина, по которой изменяется схема архитектуры. Часто ее изображают в виде шестиугольника, потому что уже не имеет смысла говорить о «верхнем» или «нижнем» слое. Вместо этого шестиугольная архитектура говорит преимущественно о «внешней» и «внутренней» частях приложения.

Есть отличные видео на YouTube от Матиаса Нобека, где он рассказывает о шестиугольной архитектуре. Возможно, вам стоит посмотреть одно из них.

