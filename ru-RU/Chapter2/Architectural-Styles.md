# 2. Архитектурные стили
Чтобы иметь возможность создавать сложные приложения, одним из ключевых требований является наличие 
архитектурного проекта, соответствующего потребностям приложения. Одним из преимуществ доменно-ориентированного 
проектирования является то, что оно не привязано к какому-либо конкретному стилю архитектуры. 
Вместо этого мы свободны выбирать архитектуру, которая лучше всего соответствует потребностям каждого 
ограниченного контекста внутри основного домена, который предлагает разнообразный набор архитектурных решений 
для каждой конкретной проблемы домена.

Например, система обработки заказов может использовать источник событий для отслеживания всех различных операций 
с заказами; Каталог продуктов может использовать CQRS для предоставления сведений о продукте различным клиентам; 
а система управления контентом может использовать простую шестиугольную архитектуру для предоставления таких требований,
как блоги, статические страницы и т. д.

В этой главе представлено введение во все соответствующие архитектурные стили в мире PHP, прослеживающие эволюцию 
от традиционного PHP-кода «старой школы» к более сложной архитектуре. Обратите внимание: хотя существует множество 
других существующих архитектурных стилей, таких как Data Fabric или SOA, мы считаем их слишком сложными 
для представления с точки зрения PHP.

## 2.1 Старые добрые времена
До выпуска PHP 5 язык не поддерживал объектно-ориентированную парадигму. В то время обычным способом написания 
приложений было использование процедур и глобального состояния. Такие концепции, как разделение ответственности, 
MVC и тому подобное, были чужды сообществу PHP. В приведенном ниже примере показано приложение, 
написанное традиционным способом, где приложения состоят из множества фронт-контроллеров, смешанных с HTML-кодом. 
За это время код уровней инфраструктуры, представления, пользовательского интерфейса и предметной области перепутался:

```php
<?php
include __DIR__ . '/bootstrap.php';

$db = new PDO('mysql:host=localhost;dbname=my_database', 'a_username', '4_p4ssw0\ rd', [
    PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES utf8mb4',
]);

$errormsg = null;

if (isset($_POST['submit'] && isValid($_POST['post'])) { 
    $post = getFrom($_POST['post']); 
    $db->beginTransaction();
    
    try {
        $stm = $db->prepare('INSERT INTO posts (title, content) VALUES (?, ?)'); 
        $stm->execute([
            $post['title'],
            $post['content']
        ]);
        $db->commit();
    } catch (Exception $e) {
        $db->rollback();
        $errormsg = 'Post could not be created! :(';
    }
}
$stm = $db->prepare('SELECT id, title, content FROM posts'); 
$posts = $stm->fetchAll(PDO::FETCH_ASSOC);
?>
<html>
    <head></head>
    <body>
        <?php if (null !== $errormsg): ?>
            <div class="alert error"><?php echo $errormsg; ?></div>
        <?php else: ?>
            <div class="alert success">Bravo! Post was created successfully!</div> 
        <?php endif; ?>
        
        <table>
            <thead><tr><th>ID</th><th>TITLE</th><th>ACTIONS</th></tr></thead> 
            <tbody>
                <?php foreach ($posts as $post): ?>
                    <tr>
                        <td><?php echo $post['ID']; ?></td> 
                        <td><?php echo $post['TITLE']; ?></td> 
                        <td><?php editPostUrl($post['ID']); ?></td>
                    </tr>
                <?php endforeach; ?> 
            </tbody>
        </table>
    </body>
</html>

```

Этот стиль кодирования часто Большой Ком Грязи (Big Ball of Mud), о котором мы упоминали в первой главе. Однако улучшение, 
замеченное в этом стиле, заключалось в инкапсуляции верхнего и нижнего колонтитула веб-страницу в отдельных файлах,
которые были включены в файлы верхнего и нижнего колонтитула. 
Это позволило избежать дублирования и способствовало повторному использованию.

```php
<?php
include __DIR__ . '/bootstrap.php';

$db = new PDO('mysql:host=localhost;dbname=my_database', 'a_username', '4_p4ssw0\ rd', [
    PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES utf8mb4',
]);

$errormsg = null;

if (isset($_POST['submit'] && isValid($_POST['post'])) { 
    $post = getFrom($_POST['post']); 
    $db->beginTransaction();
    
    try {
        $stm = $db->prepare('INSERT INTO posts (title, content) VALUES (?, ?)'); 
        $stm->execute([
            $post['title'],
            $post['content']
        ]);
        $db->commit();
    } catch (Exception $e) {
        $db->rollback();
        $errormsg = 'Post could not be created! :(';
    }
}
$stm = $db->prepare('SELECT id, title, content FROM posts'); 
$posts = $stm->fetchAll(PDO::FETCH_ASSOC);
?>
<?php include __DIR__ . '/header.php'; ?>

<?php if (null !== $errormsg): ?>
    <div class="alert error"><?php echo $errormsg; ?></div>
<?php else: ?>
    <div class="alert success">Bravo! Post was created successfully!</div> 
<?php endif; ?>

<table>
    <thead><tr><th>ID</th><th>TITLE</th><th>ACTIONS</th></tr></thead> 
    <tbody>
        <?php foreach ($posts as $post): ?>
            <tr>
                <td><?php echo $post['ID']; ?></td> 
                <td><?php echo $post['TITLE']; ?></td> 
                <td><?php editPostUrl($post['ID']); ?></td>
            </tr>
        <?php endforeach; ?> 
    </tbody>
</table>

<?php include __DIR__ . '/footer.php'; ?>
```

В настоящее время, хотя это крайне не рекомендуется, все еще существуют приложения, использующие этот 
процедурный способ кодирования. Основным недостатком этого стиля архитектуры является отсутствие реального 
разделения задач — затраты на обслуживание и развитие разрабатываемого таким образом приложения резко возрастают 
по сравнению с другими известными и проверенными архитектурами.

## 2.2 Многоуровневая архитектура
С точки зрения удобства сопровождения кода и повторного использования лучший способ сделать этот код немного 
проще в обслуживании — это разделить концепции — создать уровни для каждой отдельной задачи. 
В нашем предыдущем примере легко сформировать несколько разных уровней: один для инкапсуляции доступа к данным 
и манипулирования ими, другой для решения проблем инфраструктуры и последний для инкапсуляции оркестрации 
двух предыдущих. Важным правилом многоуровневой архитектуры является то, что каждый уровень должен быть тесно связан 
со слоями, находящимися под ним, как показано на следующем рисунке:

![Многоуровневая архитектура](https://github.com/iextra/dddinphp/blob/main/ru-RU/img/image-0001.jpeg)

Чего на самом деле добивается многоуровневая архитектура, так это разделения различных компонентов приложения. 
Например, в рамках предыдущего примера представление сообщения в блоге должно быть полностью независимым 
от сообщения в блоге как концептуальной сущности. Вместо этого сообщение в блоге как концептуальная сущность 
может быть связано с одним или несколькими представлениями, а не быть тесно связанным с конкретным представлением. 
Это обычно называется разделением интересов.

Другая архитектурная парадигма и шаблон, преследующие ту же цель, — это шаблон Модель-Представление-Контроллер. 
Первоначально он задумывался и широко использовался для создания настольных приложений с графическим интерфейсом, 
а теперь в основном используется в веб-приложениях благодаря популярным веб-фреймворкам,
таким как Symfony, Zend Framework и CodeIgniter.

